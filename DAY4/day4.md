# Day 4: Gate-Level Simulation (GLS), Blocking vs Non-Blocking in Verilog, and Synthesis-Simulation Mismatch

Welcome to Day 4! This session covers three fundamental topics crucial for digital design verification and synthesis quality:

- Gate-Level Simulation (GLS)
- Blocking vs Non-Blocking Assignments in Verilog
- Synthesis-Simulation Mismatch

---

## 1. Gate-Level Simulation (GLS)

Gate-Level Simulation is performed post-synthesis using the gate-level netlist to verify functional correctness and timing behavior. It can include realistic timing delays through SDF annotations for setup/hold verification and power estimation.

- Validates synthesized RTL mapped to gates.
- Detects timing violations and glitches early.
- Verifies testability including scan chains before layout.

GLS happens after synthesis and before physical design.

---

## 2. Synthesis-Simulation Mismatch

Simulation and synthesis mismatch occurs when RTL simulation results differ from gate-level or hardware behavior. Common causes:

- Coding styles non-synthesizable by tools (delays, initial blocks).
- Missing or wrong sensitivity lists in always blocks.
- Tool differences in interpreting RTL constructs.
- Ambiguous or incomplete RTL (missing else branches).

Mitigation involves writing clean, unambiguous synthesizable RTL using best practices.

---

## 3. Blocking vs Non-Blocking Assignments in Verilog

### 3.1 Blocking Assignments (`=`)

- Execute sequentially and immediately.
- Suitable for combinational logic.
- Updates happen in code order.

Example:
always @(*) y = a & b;

text

### 3.2 Non-Blocking Assignments (`<=`)

- Schedule updates at the end of the time step.
- Suitable for sequential logic.
- Updates concurrent, modeling register behavior.

Example:
always @(posedge clk) q <= d;

text

### 3.3 Comparison Table

| Blocking (`=`)         | Non-Blocking (`<=`)        |
|-----------------------|----------------------------|
| Immediate execution    | Scheduled execution        |
| Used in combinational  | Used in sequential         |
| Updates in order      | Updates after all RHS eval |
| Can cause race issues  | Avoids race conditions     |

---

## 4. Synthesis-Simulation Mismatch, Blocking/Non-Blocking Assignments, and Gate-Level Simulation

### Introduction

Synthesis-simulation mismatch is one of the most practical challenges in digital design. It occurs when the behavior of your RTL simulation diverges from what is observed after synthesis or on hardware. Understanding why this happens—and how to avoid it—is essential to successful tapeouts. Assignment styles (`=` for blocking, `<=` for non-blocking), sensitivity lists, and Verilog constructs play key roles. Gate-Level Simulation (GLS) is a vital step for catching such issues before physical implementation.

---

### Theory & Best Practices

#### 1. Synthesis-Simulation Mismatch

A mismatch happens when:
- RTL testbench waveform does not match gate-level simulation waveform.
- Hardware fails in operation even after passing RTL simulation.

**Root Causes:**
- Using assignments incorrectly (blocking/non-blocking confusion).
- Incomplete sensitivity lists in combinational always blocks (`always @(sel)` instead of `always @(*)`).
- Using delays or constructs not supported by synthesis.
- Simulation order and dependency ambiguities (variable evaluation before assignment).

**Best Practices:**
- Always use `always @(*)` for combinational logic blocks.
- For combinational logic, prefer blocking assignments (`=`); for sequential (`posedge clk`), use non-blocking (`<=`).
- Order assignments and intermediate calculations carefully.
- Avoid `initial`, `wait`, and delay (`#`) statements.

---

#### 2. Blocking vs Non-Blocking Assignments

**Blocking assignment (`=`):**
- Executes statements in order, values update immediately.
- Suited for combinational logic, especially temporary/intermediate calculations.

**Non-blocking assignment (`<=`):**
- Schedules updates for the end of simulation timestep.
- Suited for sequential logic and reliably modeling flip-flops/registers.

**Example Difference:**
always @(*) begin
x = a | b; // blocking: available immediately after assignment
y = x & c; // gets the updated value of x within same block
end

text

**Pitfall:**
always @(*) begin
y = x & c;
x = a | b;
end

text
In the above, `y` uses the *old* value of `x` because assignment to `x` happens *after* it's used, leading to simulation-synthesis mismatch.

---

#### 3. Gate-Level Simulation (GLS)

**GLS** is simulation of the gate-level netlist generated by the synthesis tool. Unlike RTL simulation, gate-level simulation includes real cell delays, mapped cells, and artifact glitches. GLS is the proof that RTL and synthesized logic function identically.

- Used for setup/hold timing verification.
- Highlights real-world propagation and race conditions.
- Uses netlist and vendor primitive libraries (`sky130_fd_sc_hd.v`, etc.).
- Should be run after every major synthesis step, especially before tapeout.

---

### Labs

---

#### Lab 1: Ternary Operator MUX

**Theory:**  
A 2:1 Multiplexer implemented with a ternary operator is simple and synthesizable. No mismatch occurs if coded clearly.

**Verilog:**
module ternary_operator_mux (input i0, input i1, input sel, output y);
assign y = sel ? i1 : i0;
endmodule

text

**Yosys Synthesis:**
read_liberty -lib ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib
read_verilog ternary_operator_mux.v
synth -top ternary_operator_mux
dfflibmap -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib
abc -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib
write_verilog -noattr ternary_operator_net.v
quit

text

**Simulation (RTL & GLS):**
RTL sim: use original design + testbench
iverilog -o ternary_operator_sim ternary_operator_mux.v tb_ternary_operator_mux.v
vvp ternary_operator_sim
gtkwave tb_ternary_operator_mux.vcd

GLS: Use synthesized netlist + primitives
iverilog -o ternary_operator_sim_gls
../my_lib/verilog_model/primitives.v
../my_lib/verilog_model/sky130_fd_sc_hd.v
ternary_operator_net.v
tb_ternary_operator_mux.v
vvp ternary_operator_sim_gls
gtkwave tb_ternary_operator_mux.vcd

text

*Insert simulation and synthesis waveforms.*

---

#### Lab 2: Bad MUX Example

**Theory:**  
Mux coded with wrong sensitivity list (`always @(sel)`) and non-blocking assignments in combinational logic (`<=`) creates simulation-synthesis mismatch. Synthesis tool may infer latches or ignore intended logic, producing incorrect netlist.

**Verilog (problematic):**
module bad_mux (input i0, input i1, input sel, output reg y);
always @ (sel) begin
if (sel)
y <= i1;
else
y <= i0;
end
endmodule

text

**Pitfalls:**
- Incomplete sensitivity (`sel` only).
- Non-blocking (`<=`) for combinational logic.
- Possible latch inference or incorrect netlist.

**Corrected Version:**
always @ (*) begin
if (sel)
y = i1;
else
y = i0;
end

text

**Yosys Synthesis:**
read_liberty -lib ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib
read_verilog bad_mux.v
synth -top bad_mux
dfflibmap -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib
abc -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib
write_verilog -noattr bad_mux_net.v
quit

text

**Simulation Commands:**
RTL sim: use original design + testbench
iverilog -o bad_mux_sim bad_mux.v tb_bad_mux.v
vvp bad_mux_sim
gtkwave tb_bad_mux.vcd

GLS: Use synthesized netlist + primitives
iverilog -o bad_mux_sim_gls
../my_lib/verilog_model/primitives.v
../my_lib/verilog_model/sky130_fd_sc_hd.v
bad_mux_net.v
tb_bad_mux.v
vvp bad_mux_sim_gls
gtkwave tb_bad_mux.vcd

text

*Insert comparison screenshots: show waveform mismatch between RTL and GLS due to coding error.*

---

#### Lab 3: Blocking Assignment Caveat

**Theory:**  
Assignment order in always blocks matters. Blocking assignments update variables in code order; using a variable before it's assigned can cause mismatches and race conditions.

**Example (problematic):**
module blocking_caveat (input a, input b, input c, output reg d);
reg x;
always @ (*) begin
d = x & c; // uses old x value
x = a | b; // new value assigned after d calculation
end
endmodule

text

**Corrected Version:**
always @ (*) begin
x = a | b;
d = x & c; // now uses updated x
end

text

**Commands:**
- Run simulation on both versions; observe variable dependency in waveforms.
- Synthesize only corrected version; netlist matches corrected RTL.

*Insert waveforms showing bug and fix.*

---

#### General Analysis Steps (for every lab):

1. Simulate RTL and observe output waveform.
2. Synthesize RTL using Yosys and generate gate-level netlist.
3. Simulate gate-level (GLS) using synthesized netlist and sky130 primitives; observe waveform.
4. Compare results. Diagnose mismatch causes (assignment style, sensitivity list, ordering).
5. Correct RTL and repeat; verify waveform match.
6. Document each cause and best practice in your notes.

---

**Summary:**  
- Synthesis-simulation mismatch is most often caused by poor Verilog coding, sensitivity list errors, and assignment confusion.
- Blocking assignment (`=`) is only safe for combinational; non-blocking (`<=`) for sequential.
- GLS must always be checked to prove correctness before chip tapeout.
- Review waveforms and fix errors early!

---

*Add your screenshots below each lab for full documentation of the learning process.*
## 4. Labs

### Lab 1: Ternary Operator MUX

Example of 2:1 mux using ternary operator assigning `y = sel ? i1 : i0`.

Yosys commands:
```
read_liberty -lib ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib
read_verilog ternary_operator_mux.v
synth -top ternary_operator_mux
dfflibmap -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib
abc -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib
write_verilog -noattr ternary_operator_net.v
quit
```


Simulation commands:
```
iverilog -o ternary_operator_sim ../my_lib/verilog_model/primitives.v ../my_lib/verilog_model/sky130_fd_sc_hd.v ternary_operator_net.v tb_ternary_operator_mux.v
vvp ternary_operator_sim
gtkwave tb_ternary_operator_mux.vcd
```

*Insert simulation and synthesis screenshots here*

---

### Lab 2: Bad MUX Example

MUX with incomplete sensitivity list and wrong assignment styles, demonstrating pitfalls.

Yosys commands:
```
read_liberty -lib ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib
read_verilog bad_mux.v
synth -top bad_mux
dfflibmap -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib
abc -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib
write_verilog -noattr bad_mux_net.v
quit
```

Simulation commands:
iverilog -o bad_mux_sim ../my_lib/verilog_model/primitives.v ../my_lib/verilog_model/sky130_fd_sc_hd.v bad_mux_net.v tb_bad_mux.v
vvp bad_mux_sim
gtkwave tb_bad_mux.vcd
```

*Insert simulation and synthesis screenshots here*

---

## 5. Summary

- Gate-Level Simulation is essential for verifying synthesized designs under realistic conditions.
- Proper RTL coding prevents synthesis-simulation mismatches.
- Use blocking assignments in combinational and non-blocking in sequential code to model hardware accurately.
- Labs reinforced theoretical concepts through practical synthesis and simulation.

---
