# Day 4: Gate-Level Simulation (GLS), Blocking vs Non-Blocking in Verilog, and Synthesis-Simulation Mismatch

## Table of Contents

- [1. Gate-Level Simulation (GLS)](#1-gate-level-simulation-gls)
- [2. Synthesis-Simulation Mismatch](#2-synthesis-simulation-mismatch)
- [3. Blocking vs Non-Blocking Assignments in Verilog](#3-blocking-vs-non-blocking-assignments-in-verilog)

- [Lab 1: Ternary Operator MUX](#lab-1-ternary-operator-mux)
- [Lab 2: Bad MUX Example](#lab-2-bad-mux-example)
- [Lab 3: Blocking Assignment Caveat](#lab-3-blocking-assignment-caveat)

- [5. Summary](#5-summary)


---

## 1. Gate-Level Simulation (GLS)
**GLS** is simulation of the gate-level netlist generated by the synthesis tool. Unlike RTL simulation, gate-level simulation includes real cell delays, mapped cells, and artifact glitches. GLS is the proof that RTL and synthesized logic function identically.

Gate-Level Simulation is performed post-synthesis using the gate-level netlist to verify functional correctness and timing behavior. It can include realistic timing delays through SDF annotations for setup/hold verification and power estimation.

- Used for setup/hold timing verification.
- Highlights real-world propagation and race conditions.
- Uses netlist and vendor primitive libraries (`sky130_fd_sc_hd.v`, etc.).
- Should be run after every major synthesis step, especially before tapeout.
- Validates synthesized RTL mapped to gates.
- Detects timing violations and glitches early.
- Verifies testability including scan chains before layout.

GLS happens after synthesis and before physical design.

---

## 2. Synthesis-Simulation Mismatch
  A mismatch happens when:
- RTL testbench waveform does not match gate-level simulation waveform.
- Hardware fails in operation even after passing RTL simulation.
  
**Common causes:**
- Coding styles non-synthesizable by tools (delays, initial blocks).
- Missing or wrong sensitivity lists in always blocks.
- Tool differences in interpreting RTL constructs.
- Ambiguous or incomplete RTL (missing else branches).

**Root Causes:**
- Using assignments incorrectly (blocking/non-blocking confusion).
- Incomplete sensitivity lists in combinational always blocks (`always @(sel)` instead of `always @(*)`).
- Using delays or constructs not supported by synthesis.
- Simulation order and dependency ambiguities (variable evaluation before assignment).

**Best Practices:**
- Always use `always @(*)` for combinational logic blocks.
- For combinational logic, prefer blocking assignments (`=`); for sequential (`posedge clk`), use non-blocking (`<=`).
- Order assignments and intermediate calculations carefully.
- Avoid `initial`, `wait`, and delay (`#`) statements.


Mitigation involves writing clean, unambiguous synthesizable RTL using best practices.

---

## 3. Blocking vs Non-Blocking Assignments in Verilog

### 3.1 Blocking Assignments (`=`)

- Execute sequentially and immediately.
- Suitable for combinational logic.
- Updates happen in code order.

Example:
```
always @(*) y = a & b;
```


### 3.2 Non-Blocking Assignments (`<=`)

- Schedule updates at the end of the time step.
- Suitable for sequential logic.
- Updates concurrent, modeling register behavior.
  

Example:
```
always @(posedge clk) q <= d;

```
### 3.3 Comparison Table

| Blocking (`=`)         | Non-Blocking (`<=`)        |
|-----------------------|----------------------------|
| Immediate execution    | Scheduled execution        |
| Used in combinational  | Used in sequential         |
| Updates in order      | Updates after all RHS eval |
| Can cause race issues  | Avoids race conditions     |

---

**Pitfall:**
```verilog
always @(*) begin
y = x & c;
x = a | b;
end
```

In the above, `y` uses the *old* value of `x` because assignment to `x` happens *after* it's used, leading to simulation-synthesis mismatch.

---


### 4.Labs

---

#### Lab 1: Ternary Operator MUX

A 2:1 Multiplexer implemented with a ternary operator is simple and synthesizable. No mismatch occurs if coded clearly.

**Verilog Code:**
```verilog
module ternary_operator_mux (input i0, input i1, input sel, output y);
assign y = sel ? i1 : i0;
endmodule
```

**Simulation (RTL & GLS):**
RTL sim: use original design + testbench
```
iverilog -o ternary_operator_sim ternary_operator_mux.v tb_ternary_operator_mux.v
vvp ternary_operator_sim
gtkwave tb_ternary_operator_mux.vcd
```
<div align="center">
  <img src="https://github.com/ShravanaHS/week1-riscV-soc-tapeout-vsd/blob/main/images/ternarywave.png"/>
  <br>
  <b>Ternary operator mux</b>
</div>

**Yosys Synthesis:**
```
read_liberty -lib ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib
read_verilog ternary_operator_mux.v
synth -top ternary_operator_mux
abc -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib
write_verilog -noattr ternary_operator_net.v
quit
```
<div align="center">
  <img src="https://github.com/ShravanaHS/week1-riscV-soc-tapeout-vsd/blob/main/images/ternaryoperatorsyn.png"/>
  <br>
  <b>Ternary operator mux</b>
</div>


GLS: Use synthesized netlist + primitives
```
iverilog -o ternary_operator_sim_gls
../my_lib/verilog_model/primitives.v
../my_lib/verilog_model/sky130_fd_sc_hd.v
ternary_operator_net.v
tb_ternary_operator_mux.v
vvp ternary_operator_sim_gls
gtkwave tb_ternary_operator_mux.vcd
```
<div align="center">
  <img src="https://github.com/ShravanaHS/week1-riscV-soc-tapeout-vsd/blob/main/images/ternarywave.png"/>
  <br>
  <b>Ternary operator mux</b>
</div>


---

#### Lab 2: Bad MUX Example

Mux coded with wrong sensitivity list (`always @(sel)`) and non-blocking assignments in combinational logic (`<=`) creates simulation-synthesis mismatch. Synthesis tool may infer latches or ignore intended logic, producing incorrect netlist.

**Verilog (problematic):**
```verilog
module bad_mux (input i0, input i1, input sel, output reg y);
always @ (sel) begin
if (sel)
y <= i1;
else
y <= i0;
end
endmodule
```

**Pitfalls:**
- Incomplete sensitivity (`sel` only).
- Non-blocking (`<=`) for combinational logic.
- Possible latch inference or incorrect netlist.

**Corrected Version:**
```verilog
always @ (*) begin
if (sel)
y = i1;
else
y = i0;
end
```
**Simulation Commands:**
RTL sim: use original design + testbench
```
iverilog -o bad_mux_sim bad_mux.v tb_bad_mux.v
vvp bad_mux_sim
gtkwave tb_bad_mux.vcd
```
<div align="center">
  <img src="https://github.com/ShravanaHS/week1-riscV-soc-tapeout-vsd/blob/main/images/badmuxbeforesyn.png"/>
  <br>
  <b>Bad mux RTL Waveform</b>
</div>

**Yosys Synthesis:**
```
read_liberty -lib ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib
read_verilog bad_mux.v
synth -top bad_mux
abc -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib
write_verilog -noattr bad_mux_net.v
quit
```

GLS: Use synthesized netlist + primitives
```
iverilog -o bad_mux_sim_gls
../my_lib/verilog_model/primitives.v
../my_lib/verilog_model/sky130_fd_sc_hd.v
bad_mux_net.v
tb_bad_mux.v
vvp bad_mux_sim_gls
gtkwave tb_bad_mux.vcd
```
<div align="center">
  <img src="https://github.com/ShravanaHS/week1-riscV-soc-tapeout-vsd/blob/main/images/badmuxaftsyn.png"/>
  <br>
  <b>badmux after synthesis</b>
</div>

---

#### Lab 3: Blocking Assignment Caveat

Assignment order in always blocks matters. Blocking assignments update variables in code order; using a variable before it's assigned can cause mismatches and race conditions.

**Example (problematic):**
```verilog
module blocking_caveat (input a, input b, input c, output reg d);
reg x;
always @ (*) begin
d = x & c; // uses old x value
x = a | b; // new value assigned after d calculation
end
endmodule
```

**Corrected Version:**
```verilog
always @ (*) begin
x = a | b;
d = x & c; // now uses updated x
end
```

<div align="center">
  <img src="https://github.com/ShravanaHS/week1-riscV-soc-tapeout-vsd/blob/main/images/beforesyncav.png"/>
  <br>
  <b>Blocking caveat</b>
</div>
<div align="center">
  <img src="https://github.com/ShravanaHS/week1-riscV-soc-tapeout-vsd/blob/main/images/cavaftersyn.png"/>
  <br>
  <b>Blocking caveat after synthesis</b>
</div>
<div align="center">
  <img src="https://github.com/ShravanaHS/week1-riscV-soc-tapeout-vsd/blob/main/images/syscav.png"/>
  <br>
  <b>Blocking caveat</b>
</div>


## 5. Summary

- Gate-Level Simulation is essential for verifying synthesized designs under realistic conditions.
- Proper RTL coding prevents synthesis-simulation mismatches.
- Use blocking assignments in combinational and non-blocking in sequential code to model hardware accurately.
- Labs reinforced theoretical concepts through practical synthesis and simulation.

---
